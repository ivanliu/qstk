%
% API Documentation for QSTK
% Module QSTK.qstklearn.parallelknn
%
% Generated by epydoc 3.0.1
% [Mon Mar  5 00:49:20 2012]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.parallelknn \textit{(module)}|(}
\section{Module QSTK.qstklearn.parallelknn}

    \label{QSTK:qstklearn:parallelknn}
Created on Feb 1, 2011

\textbf{Author:} Shreyas Joshi



\textbf{Organization:} Georgia Institute of Technology



\textbf{Contact:} shreyasj@gatech.edu



\textbf{Status:} complete. "mode" untested




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{QSTK:qstklearn:parallelknn:par_query}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.parallelknn \textit{(module)}!QSTK.qstklearn.parallelknn.par\_query \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{par\_query}(\textit{allQueries}, \textit{k}, \textit{method}={\tt \texttt{'}\texttt{mean}\texttt{'}}, \textit{noOfThreads}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxxx}

          \item[allQueries]

          is another 2D numpy array. Each row here is one query point. It 
          has no 'y' values. These have to be calculated.

          \item[k]

          no. of neighbors to consider

          \item[method]

          method of combining the 'y' values of the nearest neighbors. 
          Default is mean.

          \item[noOfThreads]

          optional parameter that specifies how many threads to create. 
          Default value: no. of threads = value returned by cpu\_count

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      A numpy array with the predicted 'y' values for the query points. The
      ith element in the array is the 'y' value for the ith query point.

      \end{quote}

    \end{boxedminipage}

    \label{QSTK:qstklearn:parallelknn:query}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.parallelknn \textit{(module)}!QSTK.qstklearn.parallelknn.query \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{query}(\textit{allQueries}, \textit{k}, \textit{method}={\tt \texttt{'}\texttt{mean}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxxxxx}

          \item[allQueries]

          is another 2D numpy array. Each row here is one query point. It 
          has no 'y' values. These have to be calculated.

          \item[k]

          no. of neighbors to consider

          \item[method]

          method of combining the 'y' values of the nearest neighbors. 
          Default is mean.

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      A numpy array with the predicted 'y' values for the query points. The
      ith element in the array is the 'y' value for the ith query point. If
      there is more than one mode then only the first mode is returned.

      \end{quote}

    \end{boxedminipage}

    \label{QSTK:qstklearn:parallelknn:addEvidence}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.parallelknn \textit{(module)}!QSTK.qstklearn.parallelknn.addEvidence \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{addEvidence}(\textit{newData})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxxxxx}

          \item[newData]

          A 2D numpy array. Each row is a data point and each column is a 
          dimension. The last dimension corresponds to 'y' values.

        \end{Ventry}

      \end{quote}

\textbf{Note:} Any dimensional data can be added the first time. After that- the data must
have the same number of columns as the data that was added the first time.



    \end{boxedminipage}

    \label{QSTK:qstklearn:parallelknn:main}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.parallelknn \textit{(module)}!QSTK.qstklearn.parallelknn.main \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{main}(\textit{args})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright d\-a\-t\-a\- & \raggedright \textbf{Value:} 
{\tt array([], dtype=float64)}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{QSTK.qstklearn}\texttt{'}}&\\
\cline{1-2}
\end{longtable}

    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.parallelknn \textit{(module)}|)}
