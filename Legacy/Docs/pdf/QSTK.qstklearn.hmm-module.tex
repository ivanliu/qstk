%
% API Documentation for QSTK
% Module QSTK.qstklearn.hmm
%
% Generated by epydoc 3.0.1
% [Mon Mar  5 00:49:20 2012]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}|(}
\section{Module QSTK.qstklearn.hmm}

    \label{QSTK:qstklearn:hmm}
This package includes code for representing and learning HMM's.

Most of the code in this package was derived from the descriptions provided
in 'A Tutorial on Hidden Markov Models and Selected Applications in Speach 
Recognition' by Lawence Rabiner.

Conventions: The keyword argument elem\_size will be passed in when 
creating numpy array objects.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Functions                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Functions}

    \label{QSTK:qstklearn:hmm:calcalpha}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.calcalpha \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{calcalpha}(\textit{stateprior}, \textit{transition}, \textit{emission}, \textit{observations}, \textit{numstates}, \textit{elem\_size}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Calculates 'alpha' the forward variable.

    The alpha variable is a numpy array indexed by time, then state (TxN). 
    alpha[t][i] = the probability of being in state 'i' after observing the
    first t symbols.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:forwardbackward}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.forwardbackward \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{forwardbackward}(\textit{stateprior}, \textit{transition}, \textit{emission}, \textit{observations}, \textit{numstates}, \textit{elem\_size}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Calculates the probability of a sequence given the HMM.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:calcbeta}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.calcbeta \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{calcbeta}(\textit{transition}, \textit{emission}, \textit{observations}, \textit{numstates}, \textit{elem\_size}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Calculates 'beta' the backward variable.

    The beta variable is a numpy array indexed by time, then state (TxN). 
    beta[t][i] = the probability of being in state 'i' and then observing 
    the symbols from t+1 to the end (T).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:calcxi}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.calcxi \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{calcxi}(\textit{stateprior}, \textit{transition}, \textit{emission}, \textit{observations}, \textit{numstates}, \textit{alpha}={\tt None}, \textit{beta}={\tt None}, \textit{elem\_size}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Calculates 'xi', a joint probability from the 'alpha' and 'beta' 
    variables.

    The xi variable is a numpy array indexed by time, state, and state 
    (TxNxN). xi[t][i][j] = the probability of being in state 'i' at time 
    't', and 'j' at time 't+1' given the entire observation sequence.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:calcgamma}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.calcgamma \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{calcgamma}(\textit{xi}, \textit{seqlen}, \textit{numstates}, \textit{elem\_size}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Calculates 'gamma' from xi.

    Gamma is a (TxN) numpy array, where gamma[t][i] = the probability of 
    being in state 'i' at time 't' given the full observation sequence.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:baumwelchstep}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.baumwelchstep \textit{(function)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{baumwelchstep}(\textit{stateprior}, \textit{transition}, \textit{emission}, \textit{observations}, \textit{numstates}, \textit{numsym}, \textit{elem\_size}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given an HMM model and a sequence of observations, computes the 
    Baum-Welch update to the parameters using gamma and xi.

\setlength{\parskip}{1ex}
    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{QSTK.qstklearn}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.HMMLearner \textit{(class)}|(}
\subsection{Class HMMLearner}

    \label{QSTK:qstklearn:hmm:HMMLearner}
\begin{alltt}

A class for modeling and learning HMMs.

This class conveniently wraps the module level functions. Class objects hold 6
data members:
- num\_states                    number of hidden states in the HMM
- num\_symbols                   number of possible symbols in the observation 
                                sequence
- precision                     precision of the numpy.array elements (defaults to
                                longdouble)
- prior                         The prior probability of starting in each state
                                (Nx1 array)
- transition\_matrix             The probability of transitioning between each state
                                (NxN matrix)
- emission\_matrix               The probability of each symbol in each state
                                (NxO matrix)
You can set the 3 matrix parameters as you wish, but make sure the shape of
the arrays matches num\_states and num\_symbols, as these are used internally

Typical usage of this class is to create an HMM with a set number of states
and external symbols, train the HMM using addEvidence(...), and then use
the sequenceProb(...) method to see how well a specific sequence matches
the trained HMM.
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{QSTK:qstklearn:hmm:HMMLearner:__init__}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.HMMLearner \textit{(class)}!QSTK.qstklearn.hmm.HMMLearner.\_\_init\_\_ \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{num\_states}, \textit{num\_symbols}, \textit{init\_type}={\tt \texttt{'}\texttt{uniform}\texttt{'}}, \textit{precision}={\tt {\textless}type 'numpy.float128'{\textgreater}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Creates a new HMMLearner object with the given number of internal 
    states, and external symbols.

    calls self.reset(init\_type=init\_type)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:HMMLearner:reset}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.HMMLearner \textit{(class)}!QSTK.qstklearn.hmm.HMMLearner.reset \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{reset}(\textit{self}, \textit{init\_type}={\tt \texttt{'}\texttt{uniform}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

Resets the 3 arrays using the given initialization method.

Wipes out the old arrays. You can use this method to change the shape
of the arrays by first changing num\_states and/or num\_symbols, and then
calling this method.

Currently supported initialization methods:
uniform         prior, transition, and emission probabilities are all 
                        uniform (default)
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:HMMLearner:sequenceProb}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.HMMLearner \textit{(class)}!QSTK.qstklearn.hmm.HMMLearner.sequenceProb \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{sequenceProb}(\textit{self}, \textit{newData})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Returns the probability that this HMM generated the given sequence.

    Uses the forward-backward algorithm.  If given an array of sequences, 
    returns a 1D array of probabilities.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{QSTK:qstklearn:hmm:HMMLearner:addEvidence}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.HMMLearner \textit{(class)}!QSTK.qstklearn.hmm.HMMLearner.addEvidence \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{addEvidence}(\textit{self}, \textit{newData}, \textit{iterations}={\tt 1}, \textit{epsilon}={\tt 0.0})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Updates this HMMs parameters given a new set of observed sequences 
    using the Baum-Welch algorithm.

    newData can either be a single (1D) array of observed symbols, or a 2D 
    matrix, each row of which is a seperate sequence. The Baum-Welch update
    is repeated 'iterations' times, or until the sum absolute change in 
    each matrix is less than the given epsilon.  If given multiple 
    sequences, each sequence is used to update the parameters in order, and
    the sum absolute change is calculated once after all the sequences are 
    processed.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}!QSTK.qstklearn.hmm.HMMLearner \textit{(class)}|)}
    \index{QSTK \textit{(package)}!QSTK.qstklearn \textit{(package)}!QSTK.qstklearn.hmm \textit{(module)}|)}
